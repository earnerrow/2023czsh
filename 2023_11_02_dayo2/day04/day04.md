symbol

Symbol 值通过`Symbol`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

Symbol 值不能与其他类型的值进行运算，会报错。

# Promise

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大

所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息

ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。

```
Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject
```

## Iterator（遍历器）的概念

Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

# Generator 函数的语法

形式上，Generator 函数是一个普通函数，但是有两个特征。一是，`function`关键字与函数名之间有一个星号；二是，函数体内部使用`yield`表达式，定义不同的内部状态（`yield`在英语里的意思就是“产出”）。

上面代码定义了一个 Generator 函数`helloWorldGenerator`，它内部有两个`yield`表达式（`hello`和`world`），即该函数有三个状态：hello，world 和 return 语句（结束执行）。

# let const var 三者之间的区别

1变量提升：** var存在变量提升，let和const不存在变量提升

 2块作用域由 `{ }`包括，let和const具有块级作用域，var不存在块级作用域

3const和let不允许重复声明变量,var可以重复声明

4不影响作用域链

# 什么是作用域,作用域链

- 作用域是可访问变量的集合。

- 在 `JavaScript `中, 对象和函数同样也是变量。

- 在 `JavaScript `中, 作用域为可访问变量，对象，函数的集合。

- 分为 全局作用域/局部作用域（函数作用域与块级作用域）

  当在`js`中使用一个变量的时候，首先`js`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域，这样的变量作用域访问的链式结构, 被称之为作用域链

# 什么是箭头函数

**简化了函数定义**使用 "箭头" ( => ) 来定义函数

### 特征 

箭头函数的this永远不会变，call、apply、bind也无法改变

箭头函数没有原型prototype，即不能用作为构造函数

箭头函数没有this, this指向定义箭头函数所处的外部环境

箭头函数没有 arguments 在箭头函数内部访问这个变量访问的是外部环境的arguments, 可以使用 ...代替

# 解构赋值

数组结构

```javascript
const [a, b] = [1, 2];
console.log(a); // 输出 1
console.log(b); // 输出 2
```

对象结构

```javascript
const { x, y } = { x: 1, y: 2 };
console.log(x); // 输出 1
console.log(y); // 输出 2
```

混合结构

```javascript
const { p: [x, y] } = { p: [1, 2] };
console.log(x); // 输出 1
console.log(y); // 输出 2
```

